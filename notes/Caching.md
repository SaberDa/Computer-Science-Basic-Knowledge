# Cache

Load balancing 的目的在于在数量不断增加的服务器上进行横向扩展，Caching 的目的在于使更好的利用现有资源，并使之前无法达到的产品需求变的可行。缓存利用了引用原则的局部性：最近请求的数据可能会被再次请求。这个几乎被应用于计算机的每个层：硬件，操作系统，Web浏览器，Web应用程序。

高速缓存就像短期内存：它具有有限的空间量，但是通常比原始数据源快，并且其包含最近访问的项目。缓存可以存在于体系结构的所有级别，但是通常位于最接近前端的级别。缓存的实现是为了在不增加下游级别负担的条件下，能够快速地返回数据。

---

### 1. Application server cache

将 cache 直接放置在请求层结点上，可以实现相应数据的本地储存。每次对服务器提出请求时，结点将快速返回本地缓存的数据（如果其存在的话）。如果被请求的数据不在 cache 中，那么请求结点将从磁盘中查询数据。一个请求层结点上的 cache 可以存在于内存之中（速度非常快），也存在于本地磁盘上（比网络储存要快）。

将其扩展到许多结点时会发生什么？如果请求层扩展到多个结点，那么每个结点仍然有可能托管其自身的 cache。但是如果负债均衡器在结点之间随机分配请求，那么相同的请求可能会到达不同的结点，从而导致缓存丢失率的增加。我们可以使用全局缓存或者分布式缓存解决该问题。


---

### 2. Distributed cache

在分布式缓存中，每个结点都拥有一部分缓存数据。通常，我们使用一致的哈希函数对缓存进行划分。这样，如果请求结点正在寻找某个数据，它可以快速地知道在分布式缓存中查找的位置，并且确定该数据是否可以使用。在这种情况下，每个结点都有一小部分缓存，然后将在发送到原始结点之前向另一个结点发送数据请求。因此，分布式缓存的优点之一是我们可以轻松地增加缓存空间，而只需要将结点添加到请求池即可实现。

分布式缓存的一个缺点在于解决丢失的结点。一些分布式缓存通过在不同结点上存储数据的多个副本来解决此问题。然而，这会使逻辑变得更加复杂，特别是当需要向请求层添加或者删除结点时。尽管即使结点消失并且部分缓存丢失，请求也只会从源中拉出，因此不一定是灾难性的。

---

### 3. Global cache

全局缓存就像它的名字一样：所有结点使用相同的单个缓存空间。这涉及到以比原始存储更快的速度添加服务器或某种文件储存，并且可由所有请求层结点访问。每个请求结点以与本地请求相同的方式查询缓存。这种缓存方案可能会变的有些复杂，因为随着客户端和请求数量的增加，很容易使单个缓存不堪重负；但是在某些架构中（尤其是那些具有专用硬件的架构）非常有效。这种使用某种专用硬件的架构可以使该全局缓存非常快。

![](https://raw.githubusercontent.com/SaberDa/System-Design-Notes/master/notes/pic/global%20cache-1.png)

上图展示了两种常见的全局缓存形式。第一种，当在缓存中找不到请求的响应时，缓存本身将负责从底层储存中检索丢失的数据。第二种，请求结点负责检索缓存中未找到的数据。

大多数使用全局缓存的应用程序倾向于使用第一种类型，其中缓存本身负责管理释放和获取数据，以防止来自客户端的对同一数据的请求泛滥。然而，在某种情况下，第二种实现更有意义。举个例子，如果缓存用于非常大的文件，则较低的缓存命中百分比将导致缓存区由于未命中二负载；在这种情况下，使用第二种方式有助于在缓存中拥有总数据集的很大一部分。第二种情况则针对某一种架构，其中储存在缓存中的文件是静态的，不应将其释放。（这可能是由于围绕该数据延迟的应用程序需求--某些数据对于大型数据集可能需要非常快--在这种情况下，应用程序逻辑比缓存更能理解释放策略或者热点）。

---

### 4. Content distribute network (CDN)

CDN是一种可服务于大量静态媒体的站点缓存。在典型的CDN设置中，请求首先向CDN询问静态媒体，如果CDN中含有本地可用的内容，那么它将提供该内容。如果该文件不可用，那么CDN将在后端服务器中查询该文件，然后将其缓存在本地并且提供给发出该请求的用户。

如果我们要构建的系统还不够大，无法拥有自己的CDN，则可以使用轻量级HTTP服务器（例如Nginx）通过将静态媒体提供给单独的子域来简化将来的过渡，然后将DNS从服务器切换到CDN。

---

## Cache Invalidation

---

## Cache eviction policies